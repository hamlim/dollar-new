{"dependencies":[{"name":"./implementation/args","loc":{"line":19,"column":22}},{"name":"./implementation/blob","loc":{"line":20,"column":24}},{"name":"./implementation/error","loc":{"line":21,"column":31}},{"name":"./implementation/location","loc":{"line":22,"column":25}},{"name":"./implementation/metadata","loc":{"line":23,"column":26}},{"name":"./implementation/object","loc":{"line":24,"column":24}},{"name":"./implementation/path","loc":{"line":25,"column":22}},{"name":"./implementation/requests","loc":{"line":26,"column":26}},{"name":"./implementation/string","loc":{"line":28,"column":29}},{"name":"./implementation/type","loc":{"line":29,"column":22}},{"name":"./task","loc":{"line":30,"column":27}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Reference = undefined;\n\nvar _args = require(\"./implementation/args\");\n\nvar args = _interopRequireWildcard(_args);\n\nvar _blob = require(\"./implementation/blob\");\n\nvar _error = require(\"./implementation/error\");\n\nvar errorsExports = _interopRequireWildcard(_error);\n\nvar _location = require(\"./implementation/location\");\n\nvar _metadata = require(\"./implementation/metadata\");\n\nvar metadata = _interopRequireWildcard(_metadata);\n\nvar _object = require(\"./implementation/object\");\n\nvar object = _interopRequireWildcard(_object);\n\nvar _path = require(\"./implementation/path\");\n\nvar path = _interopRequireWildcard(_path);\n\nvar _requests = require(\"./implementation/requests\");\n\nvar requests = _interopRequireWildcard(_requests);\n\nvar _string = require(\"./implementation/string\");\n\nvar fbsString = _interopRequireWildcard(_string);\n\nvar _type = require(\"./implementation/type\");\n\nvar type = _interopRequireWildcard(_type);\n\nvar _task = require(\"./task\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Provides methods to interact with a bucket in the Firebase Storage service.\n * @param location An fbs.location, or the URL at\n *     which to base this object, in one of the following forms:\n *         gs://<bucket>/<object-path>\n *         http[s]://firebasestorage.googleapis.com/\n *                     <api-version>/b/<bucket>/o/<object-path>\n *     Any query or fragment strings will be ignored in the http[s]\n *     format. If no value is passed, the storage object will use a URL based on\n *     the project ID of the base firebase.App instance.\n */\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Defines the Firebase Storage Reference class.\n */\nvar Reference = /** @class */function () {\n  function Reference(authWrapper, location) {\n    this.authWrapper = authWrapper;\n    if (location instanceof _location.Location) {\n      this.location = location;\n    } else {\n      this.location = _location.Location.makeFromUrl(location);\n    }\n  }\n  /**\n   * @return The URL for the bucket and path this object references,\n   *     in the form gs://<bucket>/<object-path>\n   * @override\n   */\n  Reference.prototype.toString = function () {\n    args.validate('toString', [], arguments);\n    return 'gs://' + this.location.bucket + '/' + this.location.path;\n  };\n  Reference.prototype.newRef = function (authWrapper, location) {\n    return new Reference(authWrapper, location);\n  };\n  Reference.prototype.mappings = function () {\n    return metadata.getMappings();\n  };\n  /**\n   * @return A reference to the object obtained by\n   *     appending childPath, removing any duplicate, beginning, or trailing\n   *     slashes.\n   */\n  Reference.prototype.child = function (childPath) {\n    args.validate('child', [args.stringSpec()], arguments);\n    var newPath = path.child(this.location.path, childPath);\n    var location = new _location.Location(this.location.bucket, newPath);\n    return this.newRef(this.authWrapper, location);\n  };\n  Object.defineProperty(Reference.prototype, \"parent\", {\n    /**\n     * @return A reference to the parent of the\n     *     current object, or null if the current object is the root.\n     */\n    get: function () {\n      var newPath = path.parent(this.location.path);\n      if (newPath === null) {\n        return null;\n      }\n      var location = new _location.Location(this.location.bucket, newPath);\n      return this.newRef(this.authWrapper, location);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"root\", {\n    /**\n     * @return An reference to the root of this\n     *     object's bucket.\n     */\n    get: function () {\n      var location = new _location.Location(this.location.bucket, '');\n      return this.newRef(this.authWrapper, location);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"bucket\", {\n    get: function () {\n      return this.location.bucket;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"fullPath\", {\n    get: function () {\n      return this.location.path;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"name\", {\n    get: function () {\n      return path.lastComponent(this.location.path);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"storage\", {\n    get: function () {\n      return this.authWrapper.service();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Uploads a blob to this object's location.\n   * @param data The blob to upload.\n   * @return An UploadTask that lets you control and\n   *     observe the upload.\n   */\n  Reference.prototype.put = function (data, metadata) {\n    if (metadata === void 0) {\n      metadata = null;\n    }\n    args.validate('put', [args.uploadDataSpec(), args.metadataSpec(true)], arguments);\n    this.throwIfRoot_('put');\n    return new _task.UploadTask(this, this.authWrapper, this.location, this.mappings(), new _blob.FbsBlob(data), metadata);\n  };\n  /**\n   * Uploads a string to this object's location.\n   * @param string The string to upload.\n   * @param opt_format The format of the string to upload.\n   * @return An UploadTask that lets you control and\n   *     observe the upload.\n   */\n  Reference.prototype.putString = function (string, format, opt_metadata) {\n    if (format === void 0) {\n      format = _string.StringFormat.RAW;\n    }\n    args.validate('putString', [args.stringSpec(), args.stringSpec(fbsString.formatValidator, true), args.metadataSpec(true)], arguments);\n    this.throwIfRoot_('putString');\n    var data = fbsString.dataFromString(format, string);\n    var metadata = object.clone(opt_metadata);\n    if (!type.isDef(metadata['contentType']) && type.isDef(data.contentType)) {\n      metadata['contentType'] = data.contentType;\n    }\n    return new _task.UploadTask(this, this.authWrapper, this.location, this.mappings(), new _blob.FbsBlob(data.data, true), metadata);\n  };\n  /**\n   * Deletes the object at this location.\n   * @return A promise that resolves if the deletion succeeds.\n   */\n  Reference.prototype.delete = function () {\n    args.validate('delete', [], arguments);\n    this.throwIfRoot_('delete');\n    var self = this;\n    return this.authWrapper.getAuthToken().then(function (authToken) {\n      var requestInfo = requests.deleteObject(self.authWrapper, self.location);\n      return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();\n    });\n  };\n  /**\n   *     A promise that resolves with the metadata for this object. If this\n   *     object doesn't exist or metadata cannot be retreived, the promise is\n   *     rejected.\n   */\n  Reference.prototype.getMetadata = function () {\n    args.validate('getMetadata', [], arguments);\n    this.throwIfRoot_('getMetadata');\n    var self = this;\n    return this.authWrapper.getAuthToken().then(function (authToken) {\n      var requestInfo = requests.getMetadata(self.authWrapper, self.location, self.mappings());\n      return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();\n    });\n  };\n  /**\n   * Updates the metadata for this object.\n   * @param metadata The new metadata for the object.\n   *     Only values that have been explicitly set will be changed. Explicitly\n   *     setting a value to null will remove the metadata.\n   * @return A promise that resolves\n   *     with the new metadata for this object.\n   *     @see firebaseStorage.Reference.prototype.getMetadata\n   */\n  Reference.prototype.updateMetadata = function (metadata) {\n    args.validate('updateMetadata', [args.metadataSpec()], arguments);\n    this.throwIfRoot_('updateMetadata');\n    var self = this;\n    return this.authWrapper.getAuthToken().then(function (authToken) {\n      var requestInfo = requests.updateMetadata(self.authWrapper, self.location, metadata, self.mappings());\n      return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();\n    });\n  };\n  /**\n   * @return A promise that resolves with the download\n   *     URL for this object.\n   */\n  Reference.prototype.getDownloadURL = function () {\n    args.validate('getDownloadURL', [], arguments);\n    this.throwIfRoot_('getDownloadURL');\n    return this.getMetadata().then(function (metadata) {\n      var url = metadata['downloadURLs'][0];\n      if (type.isDef(url)) {\n        return url;\n      } else {\n        throw errorsExports.noDownloadURL();\n      }\n    });\n  };\n  Reference.prototype.throwIfRoot_ = function (name) {\n    if (this.location.path === '') {\n      throw errorsExports.invalidRootOperation(name);\n    }\n  };\n  return Reference;\n}();\nexports.Reference = Reference;\n\n//# sourceMappingURL=reference.js.map"},"hash":"18573da71a5679964002d52bd67fdc07"}