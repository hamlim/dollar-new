{"dependencies":[{"name":"./array","loc":{"line":16,"column":23}},{"name":"./blob","loc":{"line":17,"column":24}},{"name":"./error","loc":{"line":18,"column":31}},{"name":"./metadata","loc":{"line":19,"column":31}},{"name":"./object","loc":{"line":20,"column":24}},{"name":"./requestinfo","loc":{"line":21,"column":28}},{"name":"./type","loc":{"line":22,"column":22}},{"name":"./url","loc":{"line":23,"column":26}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resumableUploadChunkSize = exports.ResumableUploadStatus = undefined;\nexports.handlerCheck = handlerCheck;\nexports.metadataHandler = metadataHandler;\nexports.sharedErrorHandler = sharedErrorHandler;\nexports.objectErrorHandler = objectErrorHandler;\nexports.getMetadata = getMetadata;\nexports.updateMetadata = updateMetadata;\nexports.deleteObject = deleteObject;\nexports.determineContentType_ = determineContentType_;\nexports.metadataForUpload_ = metadataForUpload_;\nexports.multipartUpload = multipartUpload;\nexports.checkResumeHeader_ = checkResumeHeader_;\nexports.createResumableUpload = createResumableUpload;\nexports.getResumableUploadStatus = getResumableUploadStatus;\nexports.continueResumableUpload = continueResumableUpload;\n\nvar _array = require(\"./array\");\n\nvar array = _interopRequireWildcard(_array);\n\nvar _blob = require(\"./blob\");\n\nvar _error = require(\"./error\");\n\nvar errorsExports = _interopRequireWildcard(_error);\n\nvar _metadata = require(\"./metadata\");\n\nvar MetadataUtils = _interopRequireWildcard(_metadata);\n\nvar _object = require(\"./object\");\n\nvar object = _interopRequireWildcard(_object);\n\nvar _requestinfo = require(\"./requestinfo\");\n\nvar _type = require(\"./type\");\n\nvar type = _interopRequireWildcard(_type);\n\nvar _url = require(\"./url\");\n\nvar UrlUtils = _interopRequireWildcard(_url);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction handlerCheck(cndn) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\nfunction metadataHandler(authWrapper, mappings) {\n  function handler(xhr, text) {\n    var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n    handlerCheck(metadata !== null);\n    return metadata;\n  }\n  return handler;\n}\nfunction sharedErrorHandler(location) {\n  function errorHandler(xhr, err) {\n    var newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\nfunction objectErrorHandler(location) {\n  var shared = sharedErrorHandler(location);\n  function errorHandler(xhr, err) {\n    var newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\nfunction getMetadata(authWrapper, location, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'GET';\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new _requestinfo.RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nfunction updateMetadata(authWrapper, location, metadata, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'PATCH';\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var headers = { 'Content-Type': 'application/json; charset=utf-8' };\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new _requestinfo.RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nfunction deleteObject(authWrapper, location) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'DELETE';\n  var timeout = authWrapper.maxOperationRetryTime();\n  function handler(xhr, text) {}\n  var requestInfo = new _requestinfo.RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nfunction determineContentType_(metadata, blob) {\n  return metadata && metadata['contentType'] || blob && blob.type() || 'application/octet-stream';\n}\nfunction metadataForUpload_(location, blob, opt_metadata) {\n  var metadata = object.clone(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\nfunction multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var headers = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n  function genBoundary() {\n    var str = '';\n    for (var i = 0; i < 2; i++) {\n      str = str + Math.random().toString().slice(2);\n    }\n    return str;\n  }\n  var boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  var preBlobPart = '--' + boundary + '\\r\\n' + 'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' + metadataString + '\\r\\n--' + boundary + '\\r\\n' + 'Content-Type: ' + metadata['contentType'] + '\\r\\n\\r\\n';\n  var postBlobPart = '\\r\\n--' + boundary + '--';\n  var body = _blob.FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  var urlParams = { name: metadata['fullPath'] };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new _requestinfo.RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nvar ResumableUploadStatus = /** @class */function () {\n  function ResumableUploadStatus(current, total, finalized, metadata) {\n    this.current = current;\n    this.total = total;\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n  return ResumableUploadStatus;\n}();\nexports.ResumableUploadStatus = ResumableUploadStatus;\nfunction checkResumeHeader_(xhr, opt_allowed) {\n  var status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  var allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status;\n}\nfunction createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var urlParams = { name: metadata['fullPath'] };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var timeout = authWrapper.maxUploadRetryTime();\n  function handler(xhr, text) {\n    checkResumeHeader_(xhr);\n    var url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return url;\n  }\n  var requestInfo = new _requestinfo.RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nfunction getResumableUploadStatus(authWrapper, location, url, blob) {\n  var headers = { 'X-Goog-Upload-Command': 'query' };\n  function handler(xhr, text) {\n    var status = checkResumeHeader_(xhr, ['active', 'final']);\n    var sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    var size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new _requestinfo.RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nvar resumableUploadChunkSize = exports.resumableUploadChunkSize = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nfunction continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  var status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  var bytesLeft = status.total - status.current;\n  var bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  var startByte = status.current;\n  var endByte = startByte + bytesToUpload;\n  var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  var headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  var body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  function handler(xhr, text) {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    var newCurrent = status.current + bytesToUpload;\n    var size = blob.size();\n    var metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n  }\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new _requestinfo.RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n//# sourceMappingURL=requests.js.map"},"hash":"879676f41d54351f22ecc1003c8fd543"}