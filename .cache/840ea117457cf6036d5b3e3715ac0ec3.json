{"dependencies":[{"name":"./constants","loc":{"line":1,"column":27}},{"name":"./error","loc":{"line":2,"column":31}},{"name":"./failrequest","loc":{"line":3,"column":28}},{"name":"./location","loc":{"line":4,"column":25}},{"name":"./promise_external","loc":{"line":5,"column":29}},{"name":"./requestmap","loc":{"line":6,"column":27}},{"name":"./type","loc":{"line":7,"column":22}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AuthWrapper = undefined;\n\nvar _constants = require(\"./constants\");\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _error2 = require(\"./error\");\n\nvar errorsExports = _interopRequireWildcard(_error2);\n\nvar _failrequest = require(\"./failrequest\");\n\nvar _location = require(\"./location\");\n\nvar _promise_external = require(\"./promise_external\");\n\nvar promiseimpl = _interopRequireWildcard(_promise_external);\n\nvar _requestmap = require(\"./requestmap\");\n\nvar _type = require(\"./type\");\n\nvar type = _interopRequireWildcard(_type);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nvar AuthWrapper = /** @class */function () {\n  function AuthWrapper(app, maker, requestMaker, service, pool) {\n    this.bucket_ = null;\n    this.deleted_ = false;\n    this.app_ = app;\n    if (this.app_ !== null) {\n      var options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new _requestmap.RequestMap();\n  }\n  AuthWrapper.extractBucket_ = function (config) {\n    var bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    var loc = _location.Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  };\n  AuthWrapper.prototype.getAuthToken = function () {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (this.app_ !== null && type.isDef(this.app_.INTERNAL) && type.isDef(this.app_.INTERNAL.getToken)) {\n      return this.app_.INTERNAL.getToken().then(function (response) {\n        if (response !== null) {\n          return response.accessToken;\n        } else {\n          return null;\n        }\n      }, function (_error) {\n        return null;\n      });\n    } else {\n      return promiseimpl.resolve(null);\n    }\n  };\n  AuthWrapper.prototype.bucket = function () {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  };\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  AuthWrapper.prototype.service = function () {\n    return this.service_;\n  };\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  AuthWrapper.prototype.makeStorageReference = function (loc) {\n    return this.storageRefMaker_(this, loc);\n  };\n  AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {\n    if (!this.deleted_) {\n      var request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new _failrequest.FailRequest(errorsExports.appDeleted());\n    }\n  };\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  AuthWrapper.prototype.deleteApp = function () {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  };\n  AuthWrapper.prototype.maxUploadRetryTime = function () {\n    return this.maxUploadRetryTime_;\n  };\n  AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {\n    this.maxUploadRetryTime_ = time;\n  };\n  AuthWrapper.prototype.maxOperationRetryTime = function () {\n    return this.maxOperationRetryTime_;\n  };\n  AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {\n    this.maxOperationRetryTime_ = time;\n  };\n  return AuthWrapper;\n}();\nexports.AuthWrapper = AuthWrapper;\n\n//# sourceMappingURL=authwrapper.js.map"},"hash":"347463045352beaebc6d6473fc1a0b03"}